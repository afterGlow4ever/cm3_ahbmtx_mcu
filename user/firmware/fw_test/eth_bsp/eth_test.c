//===============================================
//
//	File: eth_test.c
//	Author: afterGlow,4ever
//	Group: Fall For Laboratory
//	Date: 03202024
//	Version: v1.0
//
// 	This is ethernet test source file.
//
//===============================================

#include "eth_test.h"

#ifdef ETH_TEST

//===============================================
// sma test defines
//===============================================

extern ETH_HandleTypeDef heth;
extern uint32_t b50610_init_conifg[1];
extern uint32_t b50610_reglist[5];
uint32_t tx_data[32];
uint16_t rx_data[32];
volatile uint8_t sma_callback_cnt;

//===============================================
// test prepare
//===============================================

//static void uart_tx_data_prepare(void)
//{
//	for(uint8_t i = 0; i < 32; i++)
//	{
//		tx_data[i] = 0xc3 + (i << 2);
//	}
//}

//===============================================
// sma test functions
//===============================================

void b50610_init_test(void)
{
	eth_sma_init();
	b50610_init();
}

void b50610_get_reglist_test(void)
{
	uint8_t status;

	status = drv_eth_sma_master_read_reglist(&heth, b50610_reglist, 8);
	if(status == 1)
	{
		test_printf_s("b50610 nack.\r\n");
		writereg32(0x40000000, 0xffff);
		return;
	}

	test_printf_s("b50610 read:\r\n");
	for(uint8_t i = 0; i < 5; i++)
	{
		test_printf_ch("%x ", b50610_reglist[i]);
		writereg32(0x40000004, b50610_reglist[i]);
	}	
	test_printf_s("\r\n");
}

//void yt8511_get_status_test(void)
//{
//	eth_sma_init();
//}

//void yt8511_get_status_it_test(void)
//{
//	uint16_t temp;
//
//	eth_sma_init();
//	drv_eth_sma_int_enable(&heth, ETH_SMA_INT_MASTER_FRAME_DONE);
//	NVIC_SetPriority(EthSma_IRQn, 0);
//	NVIC_EnableIRQ(EthSma_IRQn);
//
//	sma_callback_cnt = 0;
//
//	temp =  yt8511_get_status();
//	while(sma_callback_cnt != 1);
//
//	NVIC_DisableIRQ(EthSma_IRQn);
//
//	test_printf_ch("%x ", temp);
//	writereg32(0x40000000, temp);
//	test_printf_s("\r\n");
//	writereg32(0x40000004, sma_callback_cnt);
//	test_printf_ch("rx callback times: %x ", sma_callback_cnt);
//	test_printf_s("\r\n");
//}
//
//void eth_sma_int_master_frame_done_callback(ETH_HandleTypeDef *heth)
//{
//	sma_callback_cnt++;
//	writereg32(0x4000000c, sma_callback_cnt);
//}

//===============================================
// mac test defines
//===============================================

extern ETH_MAC_HandleTypeDef hethmac;
extern ETH_MAC_DmaTxDescriptorCfg hethmac_desccfg;
extern ETH_MAC_DmaDescriptorHandleTypeDef EthDmaTxDesc[ETH_MAC_TX_DESCRIPTOR_NUM];

//===============================================
// mac test prepare
//===============================================

const uint8_t eth_arp_hw_replacement_frame[] = 
{
	// des mac
	0x5c, 0x63, 0xbf, 0x77, 0x41, 0x2c,
	// src mac
	0xf4, 0x8e, 0x38, 0x88, 0x75, 0xba,
	//type
	0x08, 0x06,
	//arp
	0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x01, 0xf4, 0x8e,
	0x38, 0x88, 0x75, 0xba, 0xc0, 0xa8, 0x05, 0x78, 0x5c, 0x63,
	0xbf, 0x77, 0x41, 0x2c, 0xc0, 0xa8, 0x05, 0x01
};

const uint8_t eth_arp_hw_insertion_frame[] = 
{
	// des mac
	0x5c, 0x63, 0xbf, 0x77, 0x41, 0x2c,
	//type
	0x08, 0x06,
	//arp
	0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x01, 0xf4, 0x8e,
	0x38, 0x88, 0x75, 0xba, 0xc0, 0xa8, 0x05, 0x78, 0x5c, 0x63,
	0xbf, 0x77, 0x41, 0x2c, 0xc0, 0xa8, 0x05, 0x01
};

const uint8_t eth_tcp_hw_replacement_frame[] = 
{
	// des mac
	0x3c, 0x7c, 0x3f, 0xd7, 0x94, 0xaf,
	// src mac
	0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
	//type
	0x08, 0x00,
	//ip
	0x45, 0x04, 0x00, 0x34, 0xf7, 0x6a, 0x40, 0x00, 0x33, 0x06,
	0x00, 0x00, 0x6a, 0x0b, 0x2b, 0x9e, 0xc0, 0xa8, 0x01, 0x69,// 0,1 csf89a
	//tcp
	0x01, 0xbb, 0xde, 0xc0, 0xd3, 0x86, 0x24, 0xc6, 0x0e, 0x5f,	
	0x8d, 0x90, 0x80, 0x10, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00,// 6,7 cs755e
	0x01, 0x01, 0x05, 0x0a, 0x0e, 0x5f, 0x8d, 0x8f, 0x0e, 0x5f,
	0x8d, 0x90
};

const uint8_t eth_tcp_hw_insertion_frame[] = 
{
	// des mac
	0x3c, 0x7c, 0x3f, 0xd7, 0x94, 0xaf,
	//type
	0x08, 0x00,
	//ip
	0x45, 0x04, 0x00, 0x34, 0xf7, 0x6a, 0x40, 0x00, 0x33, 0x06,
	0x6a, 0x0b, 0x2b, 0x9e, 0xc0, 0xa8, 0x01, 0x69,// 0,1 csf89a
	//tcp
	0x01, 0xbb, 0xde, 0xc0, 0xd3, 0x86, 0x24, 0xc6, 0x0e, 0x5f,	
	0x8d, 0x90, 0x80, 0x10, 0x00, 0x0e, 0x00, 0x00,// 6,7 cs755e
	0x01, 0x01, 0x05, 0x0a, 0x0e, 0x5f, 0x8d, 0x8f, 0x0e, 0x5f,
	0x8d, 0x90
};

const uint8_t eth_icmp_hw_replacement_frame[] = 
{
	// des mac
	0x3c, 0x7c, 0x3f, 0xd7, 0x94, 0xaf,
	// src mac
	0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
	//type
	0x08, 0x00,
	//ip
	0x45, 0x00, 0x00, 0x54, 0x75, 0xad, 0x40, 0x00, 0x40, 0x01,
	0x00, 0x00, 0xc0, 0xa8, 0x01, 0x02, 0xc0, 0xa8, 0x01, 0x69,// 0,1 cs4140
	//icmp
	0x08, 0x00, 0x00, 0x00, 0x08, 0x83, 0x00, 0x00, 0xf3, 0xf2,// 2,3 cs2b7d
	0xd0, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00
};

const uint8_t eth_icmp_hw_insertion_frame[] = 
{
	// des mac
	0x3c, 0x7c, 0x3f, 0xd7, 0x94, 0xaf,
	//type
	0x08, 0x00,
	//ip
	0x45, 0x00, 0x00, 0x54, 0x75, 0xad, 0x40, 0x00, 0x40, 0x01,
	0xc0, 0xa8, 0x01, 0x02, 0xc0, 0xa8, 0x01, 0x69,// 0,1 cs4140
	//icmp
	0x08, 0x00, 0x08, 0x83, 0x00, 0x00, 0xf3, 0xf2,// 2,3 cs2b7d
	0xd0, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00
};

const uint8_t eth_udp_hw_replacement_frame[] = 
{
	// des mac
	0x8c, 0x14, 0xb4, 0x84, 0x4b, 0x48,
	// src mac
	0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
	//type
	0x08, 0x00,
	//ip
	0x45, 0x00, 0x00, 0x4c, 0x18, 0x22, 0x40, 0x00, 0x40, 0x11,
	0x00, 0x00, 0xc0, 0xa8, 0x01, 0x28, 0x6f, 0xe6, 0xbd, 0xae,// 0,1 cs331a
	//udp
	0x89, 0x34, 0x00, 0x7b, 0x00, 0x38, 0x00, 0x00, 0x23, 0x00,// 6,7 cs3af9
	0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x0c,
	0xe9, 0x2c, 0x37, 0x38, 0x89, 0xde
};

const uint8_t eth_udp_hw_insertion_frame[] = 
{
	// des mac
	0x8c, 0x14, 0xb4, 0x84, 0x4b, 0x48,
	//type
	0x08, 0x00,
	//ip
	0x45, 0x00, 0x00, 0x4c, 0x18, 0x22, 0x40, 0x00, 0x40, 0x11,
	0xc0, 0xa8, 0x01, 0x28, 0x6f, 0xe6, 0xbd, 0xae,// 0,1 cs331a
	//udp
	0x89, 0x34, 0x00, 0x7b, 0x00, 0x38, 0x23, 0x00,// 6,7 cs3af9
	0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x0c,
	0xe9, 0x2c, 0x37, 0x38, 0x89, 0xde
};

const uint8_t eth_igmp_hw_replacement_frame[] = 
{
	// des mac
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	// src mac
	0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
	//type
	0x08, 0x00,
	//ip
	0x45, 0x00, 0x00, 0x24, 0x00, 0x01, 0x00, 0x00, 0x01, 0x02,
	0x00, 0x00, 0xc0, 0xa8, 0x02, 0x02, 0xe0, 0x00, 0x00, 0x16,// 0,1 cs1717
	//igmp
	0x22, 0x00, 0xea, 0xfd, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00,	
	0x00, 0x00, 0xef, 0x00, 0x00, 0x00
};

const uint8_t eth_igmp_hw_insertion_frame[] = 
{
	// des mac
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//type
	0x08, 0x00,
	//ip
	0x45, 0x00, 0x00, 0x24, 0x00, 0x01, 0x00, 0x00, 0x01, 0x02,
	0xc0, 0xa8, 0x02, 0x02, 0xe0, 0x00, 0x00, 0x16,// 0,1 cs1717
	//igmp
	0x22, 0x00, 0xea, 0xfd, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00,	
	0x00, 0x00, 0xef, 0x00, 0x00, 0x00
};

const uint8_t eth_igmp_hw_crc_replacement_frame[] = 
{
	// des mac
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	// src mac
	0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
	//type
	0x08, 0x00,
	//ip
	0x45, 0x00, 0x00, 0x24, 0x00, 0x01, 0x00, 0x00, 0x01, 0x02,
	0x00, 0x00, 0xc0, 0xa8, 0x02, 0x02, 0xe0, 0x00, 0x00, 0x16,// 0,1 cs1717
	//igmp
	0x22, 0x00, 0xea, 0xfd, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00,	
	0x00, 0x00, 0xef, 0x00, 0x00, 0x00,
	//padding
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint8_t eth_igmp_sw_padding_crc_frame[] = 
{
	// des mac
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	// src mac
	0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
	//type
	0x08, 0x00,
	//ip
	0x45, 0x00, 0x00, 0x24, 0x00, 0x01, 0x00, 0x00, 0x01, 0x02,
	0x00, 0x00, 0xc0, 0xa8, 0x02, 0x02, 0xe0, 0x00, 0x00, 0x16,// 0,1 cs1717
	//igmp
	0x22, 0x00, 0xea, 0xfd, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00,	
	0x00, 0x00, 0xef, 0x00, 0x00, 0x00,
	//padding
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//crc
	0xa0, 0xa1, 0xa2, 0xa3//crcf38d2673
};

const uint8_t eth_udp_hw_replacement_frame2[] = 
{
	// des mac
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	// src mac
	0xe0, 0xcb, 0x4e, 0xc9, 0xdf, 0xce,
	//type
	0x08, 0x00,
	//ip
	0x45, 0x00, 0x00, 0x5f, 0x22, 0x13, 0x00, 0x00, 0x80, 0x11,
	0x00, 0x00, 0xd3, 0x45, 0xc6, 0x87, 0xff, 0xff, 0xff, 0xff,// 0,1 cs7eae
	//udp
	0x09, 0x79, 0x09, 0x79, 0x00, 0x4b, 0x00, 0x00, 0x31, 0x5f,// 6,7 csd74b
    0x6c, 0x62, 0x74, 0x32, 0x5f, 0x30, 0x23, 0x31, 0x32, 0x38, 
    0x23, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
    0x30, 0x30, 0x30, 0x23, 0x30, 0x23, 0x30, 0x23, 0x30, 0x3a, 
    0x31, 0x32, 0x38, 0x32, 0x32, 0x31, 0x32, 0x32, 0x39, 0x36, 
    0x3a, 0x6c, 0x69, 0x75, 0x73, 0x68, 0x75, 0x78, 0x69, 0x3a, 
    0x4c, 0x49, 0x55, 0x53, 0x48, 0x55, 0x58, 0x49, 0x2d, 0x50, 
    0x43, 0x3a, 0x30, 0x3a, 0x00
};

const uint8_t eth_udp_hw_insertion_frame2[] = 
{
	// des mac
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//type
	0x08, 0x00,
	//ip
	0x45, 0x00, 0x00, 0x5f, 0x22, 0x13, 0x00, 0x00, 0x80, 0x11,
	0xd3, 0x45, 0xc6, 0x87, 0xff, 0xff, 0xff, 0xff,// 0,1 cs7eae
	//udp
	0x09, 0x79, 0x09, 0x79, 0x00, 0x4b, 0x31, 0x5f,// 6,7 csd74b
    0x6c, 0x62, 0x74, 0x32, 0x5f, 0x30, 0x23, 0x31, 0x32, 0x38, 
    0x23, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
    0x30, 0x30, 0x30, 0x23, 0x30, 0x23, 0x30, 0x23, 0x30, 0x3a, 
    0x31, 0x32, 0x38, 0x32, 0x32, 0x31, 0x32, 0x32, 0x39, 0x36, 
    0x3a, 0x6c, 0x69, 0x75, 0x73, 0x68, 0x75, 0x78, 0x69, 0x3a, 
    0x4c, 0x49, 0x55, 0x53, 0x48, 0x55, 0x58, 0x49, 0x2d, 0x50, 
    0x43, 0x3a, 0x30, 0x3a, 0x00
};

static void eth_mac_tx_normal_frame_data_prepare(uint32_t data_number)
{
	uint8_t data_temp;

	data_temp = data_number % 4;
	if(data_temp)
	{
		data_number += 4 - data_temp;
	}

	for(uint32_t i = 0; i < data_number; i++)
	{
		writereg8(0x00030000 + i, i);
		writereg8(0x00030800 + i, i * 2);
		writereg8(0x00031000 + i, i);
		writereg8(0x00031800 + i, i * 2);
	}
}


static void eth_mac_tx_frame_data_prepare(uint32_t address, uint8_t data[], uint16_t data_number)
{
	uint8_t data_temp, data_additional_number = 0;

	data_temp = data_number % 4;
	if(data_temp)
	{
		data_additional_number = data_number + 4 - data_temp;
	}

	for(uint32_t i = 0; i < data_number; i++)
	{
		writereg8(address + i, data[i]);
	}
	for(uint32_t i = data_number; i < data_additional_number; i++)
	{
		writereg8(address + i, 0x00);
	}
}

//===============================================
// mac test functions
//===============================================

void eth_mac_testcase(void)
{
#ifdef TP_0
	eth_mac_tx_data_by_sw(8);
	eth_mac_tx_data_by_sw(16);
	eth_mac_tx_data_by_sw(32);
	eth_mac_tx_data_by_sw(64);
	eth_mac_tx_data_by_sw(100);
	eth_mac_tx_data_by_sw(200);
#endif
#ifdef TP_1
	eth_mac_tx_data_by_sw(2048);
#endif
#ifdef TP_2
#endif
#ifdef TP_3
#endif
#ifdef TP_4
#endif

}

void eth_mac_tx_data_by_sw(uint32_t data_number)
{
	eth_mac_tx_normal_frame_data_prepare(data_number);
	eth_mac_init();
	eth_mac_descriptor_sw_handle_prepare(data_number);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
	while(!(drv_eth_mac_dma_int_get(&hethmac) & ETH_MAC_DMA_INT_ONCE_PROCESS_DONE));
	drv_eth_mac_dma_int_allclear(&hethmac);
}

void eth_mac_tx_data_by_hw(uint32_t data_number)
{
	eth_mac_tx_normal_frame_data_prepare(data_number);
	eth_mac_init();
	eth_mac_descriptor_hw_handle_prepare(data_number);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
	while(!(drv_eth_mac_dma_int_get(&hethmac) & ETH_MAC_DMA_INT_ONCE_PROCESS_DONE));
	drv_eth_mac_dma_int_allclear(&hethmac);
}

void eth_mac_tx_arp_frame_by_hw_replacement(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_arp_hw_replacement_frame, sizeof(eth_arp_hw_replacement_frame) / sizeof(uint8_t));
	eth_mac_init();
	eth_mac_descriptor_arp_frame_replacement_hw_handle_prepare();
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
	while(!(drv_eth_mac_dma_int_get(&hethmac) & ETH_MAC_DMA_INT_ONCE_PROCESS_DONE));
	drv_eth_mac_dma_int_allclear(&hethmac);
}

void eth_mac_tx_arp_frame_by_hw_insertion(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_arp_hw_insertion_frame, sizeof(eth_arp_hw_insertion_frame) / sizeof(uint8_t));
	eth_mac_init();
	eth_mac_descriptor_arp_frame_insertion_hw_handle_prepare();
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
	while(!(drv_eth_mac_dma_int_get(&hethmac) & ETH_MAC_DMA_INT_ONCE_PROCESS_DONE));
	drv_eth_mac_dma_int_allclear(&hethmac);
}

void eth_mac_tx_ip_tcp_frame_by_hw_replacement(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_tcp_hw_replacement_frame, sizeof(eth_tcp_hw_replacement_frame) / sizeof(uint8_t));
	writereg32(0x40000000, 0x01);
	eth_mac_init();
	writereg32(0x40000000, 0x02);
	eth_mac_descriptor_ip_tcp_frame_replacement_hw_handle_prepare();
	writereg32(0x40000000, 0x03);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
	while(!(drv_eth_mac_dma_int_get(&hethmac) & ETH_MAC_DMA_INT_ONCE_PROCESS_DONE));
	drv_eth_mac_dma_int_allclear(&hethmac);
}

void eth_mac_tx_ip_tcp_frame_by_hw_insertion(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_tcp_hw_insertion_frame, sizeof(eth_tcp_hw_insertion_frame) / sizeof(uint8_t));
	writereg32(0x40000000, 0x01);
	eth_mac_init();
	writereg32(0x40000000, 0x02);
	eth_mac_descriptor_ip_tcp_frame_insertion_hw_handle_prepare();
	writereg32(0x40000000, 0x03);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
	while(!(drv_eth_mac_dma_int_get(&hethmac) & ETH_MAC_DMA_INT_ONCE_PROCESS_DONE));
	drv_eth_mac_dma_int_allclear(&hethmac);
}

void eth_mac_tx_ip_icmp_frame_by_hw_replacement(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_icmp_hw_replacement_frame, sizeof(eth_icmp_hw_replacement_frame) / sizeof(uint8_t));
	writereg32(0x40000000, 0x01);
	eth_mac_init();
	writereg32(0x40000000, 0x02);
	eth_mac_descriptor_ip_icmp_frame_replacement_hw_handle_prepare();
	writereg32(0x40000000, 0x03);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
	while(!(drv_eth_mac_dma_int_get(&hethmac) & ETH_MAC_DMA_INT_ONCE_PROCESS_DONE));
	drv_eth_mac_dma_int_allclear(&hethmac);
}

void eth_mac_tx_ip_icmp_frame_by_hw_insertion(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_icmp_hw_insertion_frame, sizeof(eth_icmp_hw_insertion_frame) / sizeof(uint8_t));
	writereg32(0x40000000, 0x01);
	eth_mac_init();
	writereg32(0x40000000, 0x02);
	eth_mac_descriptor_ip_icmp_frame_insertion_hw_handle_prepare();
	writereg32(0x40000000, 0x03);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
	while(!(drv_eth_mac_dma_int_get(&hethmac) & ETH_MAC_DMA_INT_ONCE_PROCESS_DONE));
	drv_eth_mac_dma_int_allclear(&hethmac);
}

void eth_mac_tx_ip_udp_frame_by_hw_replacement(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_udp_hw_replacement_frame, sizeof(eth_udp_hw_replacement_frame) / sizeof(uint8_t));
	writereg32(0x40000000, 0x01);
	eth_mac_init();
	writereg32(0x40000000, 0x02);
	eth_mac_descriptor_ip_udp_frame_replacement_hw_handle_prepare();
	writereg32(0x40000000, 0x03);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
	while(!(drv_eth_mac_dma_int_get(&hethmac) & ETH_MAC_DMA_INT_ONCE_PROCESS_DONE));
	drv_eth_mac_dma_int_allclear(&hethmac);
}

void eth_mac_tx_ip_udp_frame_by_hw_insertion(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_udp_hw_insertion_frame, sizeof(eth_udp_hw_insertion_frame) / sizeof(uint8_t));
	writereg32(0x40000000, 0x01);
	eth_mac_init();
	writereg32(0x40000000, 0x02);
	eth_mac_descriptor_ip_udp_frame_insertion_hw_handle_prepare();
	writereg32(0x40000000, 0x03);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
	while(!(drv_eth_mac_dma_int_get(&hethmac) & ETH_MAC_DMA_INT_ONCE_PROCESS_DONE));
	drv_eth_mac_dma_int_allclear(&hethmac);
}

void eth_mac_tx_ip_igmp_frame_by_hw_replacement(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_igmp_hw_replacement_frame, sizeof(eth_igmp_hw_replacement_frame) / sizeof(uint8_t));
	writereg32(0x40000000, 0x01);
	eth_mac_init();
	writereg32(0x40000000, 0x02);
	eth_mac_descriptor_ip_igmp_frame_replacement_hw_handle_prepare();
	writereg32(0x40000000, 0x03);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
}

void eth_mac_tx_ip_igmp_frame_by_hw_insertion(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_igmp_hw_insertion_frame, sizeof(eth_igmp_hw_insertion_frame) / sizeof(uint8_t));
	writereg32(0x40000000, 0x01);
	eth_mac_init();
	writereg32(0x40000000, 0x02);
	eth_mac_descriptor_ip_igmp_frame_insertion_hw_handle_prepare();
	writereg32(0x40000000, 0x03);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
}

void eth_mac_tx_ip_igmp_frame_by_hw_crc_replacement(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_igmp_sw_padding_crc_frame, sizeof(eth_igmp_sw_padding_crc_frame) / sizeof(uint8_t));
	writereg32(0x40000000, 0x01);
	eth_mac_init();
	writereg32(0x40000000, 0x02);
	eth_mac_descriptor_ip_igmp_frame_crc_replacement_hw_handle_prepare();
	writereg32(0x40000000, 0x03);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
}

void eth_mac_tx_ip_igmp_frame_by_hw_crc_insertion(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_igmp_hw_crc_replacement_frame, sizeof(eth_igmp_hw_crc_replacement_frame) / sizeof(uint8_t));
	writereg32(0x40000000, 0x01);
	eth_mac_init();
	writereg32(0x40000000, 0x02);
	eth_mac_descriptor_ip_igmp_frame_crc_insertion_hw_handle_prepare();
	writereg32(0x40000000, 0x03);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
}

void eth_mac_tx_ip_igmp_frame_by_sw_padding_crc(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_igmp_sw_padding_crc_frame, sizeof(eth_igmp_sw_padding_crc_frame) / sizeof(uint8_t));
	writereg32(0x40000000, 0x01);
	eth_mac_init();
	writereg32(0x40000000, 0x02);
	eth_mac_descriptor_ip_igmp_frame_padding_crc_sw_handle_prepare();
	writereg32(0x40000000, 0x03);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
}

void eth_mac_tx_ip_udp_frame2_by_hw_replacement(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_udp_hw_replacement_frame2, sizeof(eth_udp_hw_replacement_frame2) / sizeof(uint8_t));
	writereg32(0x40000000, 0x01);
	eth_mac_init();
	writereg32(0x40000000, 0x02);
	eth_mac_descriptor_ip_udp_frame2_replacement_hw_handle_prepare();
	writereg32(0x40000000, 0x03);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
}

void eth_mac_tx_ip_udp_frame2_by_hw_insertion(void)
{
	eth_mac_tx_frame_data_prepare(0x00030000, eth_udp_hw_insertion_frame2, sizeof(eth_udp_hw_insertion_frame2) / sizeof(uint8_t));
	writereg32(0x40000000, 0x01);
	eth_mac_init();
	writereg32(0x40000000, 0x02);
	eth_mac_descriptor_ip_udp_frame2_insertion_hw_handle_prepare();
	writereg32(0x40000000, 0x03);
	drv_eth_mac_set_tx_descriptor_and_tx_enable(&hethmac, EthDmaTxDesc);
}

//===============================================
// testlist
//===============================================

TestMenu g_eth_menu[] =
{
	{'1', b50610_init_test,						"[ETH SMA] b50610 init\r\n"}, 
	{'2', b50610_set_config,					"[ETH SMA] b50610 set config\r\n"}, 
	{'3', b50610_get_reglist_test,				"[ETH SMA] b50610 get reglist\r\n"}, 
	{'4', b50610_get_status,					"[ETH SMA] b50610 get status\r\n"}, 
	{'5', b50610_set_swrst,						"[ETH SMA] b50610 sw reset\r\n"}, 
//	{'4', yt8511_get_status_it_test,			"[ETH SMA] yt8511 get status int\r\n"}, 
};

void eth_testmenu(void)
{
	uint8_t num;
	num = sizeof(g_eth_menu) / sizeof(TestMenu);
	show_testmenu(g_eth_menu, num);	
	test_execute(g_eth_menu, num);
}

#endif

